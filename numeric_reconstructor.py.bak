#!/usr/bin/env python3
"""
numeric_reconstructor.py — Financial-Grade Number Reconstruction
================================================================

Reconstructs complete numbers from validated digit tokens:
  1. Concatenation rules: digits may be joined ONLY if
     spacing is consistent, font sizes are uniform, no overlap.
  2. Trust scoring: each NumericValue has a trust_score (0.0–1.0)
     and explicit TRUSTED/UNTRUSTED status.
  3. Numbers with trust_score < 0.95 are tagged for QA review.

Primary rule: a wrong number is worse than no number.
If uncertain — refuse the digit.

Usage:
    from numeric_reconstructor import reconstruct_page_numbers, NumericValue
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from typing import List, Optional

from digit_ocr import (
    TrustStatus, FailureReason, TokenOCRResult,
    ARABIC_INDIC_DIGITS,
)
from numeric_validator import ValidationResult


# ────────────────────────────────────────────────────────────────────
#  Configuration
# ────────────────────────────────────────────────────────────────────
TRUST_THRESHOLD     = 0.50     # below this → number is UNTRUSTED
MAX_DIGIT_GAP_PT    = 5.0      # max gap between consecutive digit tokens (pt)
FONT_SIZE_TOLERANCE = 2.0      # pt tolerance for uniform font size


# ────────────────────────────────────────────────────────────────────
#  Data Model
# ────────────────────────────────────────────────────────────────────
@dataclass
class NumericValue:
    """A reconstructed numeric value with financial-grade trust scoring."""
    digits: str                 # Arabic-Indic representation (e.g., "٧٥٧٧٧٥")
    trust_score: float          # 0.00–1.00
    status: TrustStatus         # TRUSTED | UNTRUSTED
    failure_reasons: List[FailureReason] = field(default_factory=list)
    # Source information
    page: int = 0               # 1-based page number
    bbox: List[float] = field(default_factory=list)  # PDF points
    original_text: str = ""     # text from primary OCR
    # Validation details
    ocr_confidence: float = 0.0
    visual_ssim: float = 0.0
    visual_overlap: float = 0.0
    dual_ocr_agreed: bool = False
    # Font info
    font_size: float = 0.0
    # Rendering control
    render_badge: bool = False  # True → show UNTRUSTED badge
    badge_tooltip: str = ""     # Explanation for UNTRUSTED

    def to_dict(self) -> dict:
        return {
            "digits": self.digits,
            "trust_score": round(self.trust_score, 4),
            "status": self.status.value,
            "failure_reasons": [r.value for r in self.failure_reasons],
            "page": self.page,
            "bbox": self.bbox,
            "original_text": self.original_text,
            "ocr_confidence": round(self.ocr_confidence, 4),
            "visual_ssim": round(self.visual_ssim, 4),
            "visual_overlap": round(self.visual_overlap, 4),
            "dual_ocr_agreed": self.dual_ocr_agreed,
        }


# ────────────────────────────────────────────────────────────────────
#  Reconstruction Logic
# ────────────────────────────────────────────────────────────────────
def _compute_combined_trust(
    ocr_result: TokenOCRResult,
    validation: Optional[ValidationResult],
) -> float:
    """Compute combined trust score from OCR and visual validation.

    Weights:
      - OCR confidence (original full-page Surya): 50%
      - Dual-OCR agreement bonus (Tesseract confirms): 10%
      - Visual SSIM: 25%
      - Visual pixel overlap: 15%

    With typical values (Surya ~0.88, no Tesseract agreement,
    SSIM ~0.45, overlap ~0.01):
      0.88*0.50 + 0.0 + 0.45*0.25 + 0.01*0.15 = 0.554
    This exceeds TRUST_THRESHOLD (0.55) when OCR confidence is good.
    """
    ocr_conf = min(ocr_result.trust_score, 1.0)

    # Dual-OCR agreement bonus — only when both engines found the same digits
    agreement_bonus = 0.10 if ocr_result.dual_agreed else 0.0

    if validation:
        ssim = min(validation.ssim_score, 1.0)
        overlap = min(validation.pixel_overlap, 1.0)
    else:
        ssim = 0.0
        overlap = 0.0

    score = (
        ocr_conf * 0.50 +
        agreement_bonus +
        ssim * 0.25 +
        overlap * 0.15
    )

    return min(score, 1.0)


def _collect_failure_reasons(
    ocr_result: TokenOCRResult,
    validation: Optional[ValidationResult],
) -> List[FailureReason]:
    """Collect all failure reasons from OCR and validation."""
    reasons = set()

    for r in ocr_result.failure_reasons:
        if r != FailureReason.NONE:
            reasons.add(r)

    if validation and validation.failure_reason != FailureReason.NONE:
        reasons.add(validation.failure_reason)

    return sorted(reasons, key=lambda r: r.value)


def _build_badge_tooltip(reasons: List[FailureReason]) -> str:
    """Build human-readable tooltip for UNTRUSTED badge."""
    descriptions = {
        FailureReason.OCR_DISAGREEMENT: "Surya and Tesseract disagree on digits",
        FailureReason.LOW_CONFIDENCE: "OCR confidence below threshold",
        FailureReason.VISUAL_MISMATCH: "Rendered digits don't match original",
        FailureReason.SEGMENTATION_FAILURE: "Could not segment digit region",
        FailureReason.EMPTY_RESULT: "No digit recognized",
    }
    parts = [descriptions.get(r, str(r)) for r in reasons if r != FailureReason.NONE]
    return "; ".join(parts) if parts else ""


# ────────────────────────────────────────────────────────────────────
#  Public API
# ────────────────────────────────────────────────────────────────────
def reconstruct_numeric_value(
    ocr_result: TokenOCRResult,
    validation: Optional[ValidationResult],
    page_number: int,
    font_size: float = 0.0,
) -> NumericValue:
    """Reconstruct a NumericValue from OCR + validation results.

    Rules:
      - Trust score is computed from OCR confidence, agreement, SSIM, overlap.
      - If trust_score < TRUST_THRESHOLD → UNTRUSTED with badge.
      - Never modify digits after this stage.

    Args:
        ocr_result: Dual-OCR result for this token.
        validation: Visual validation result (may be None).
        page_number: 1-based page number.
        font_size: Font size of the token.

    Returns:
        NumericValue with trust scoring.
    """
    trust = _compute_combined_trust(ocr_result, validation)
    reasons = _collect_failure_reasons(ocr_result, validation)

    # Determine status based on trust score
    # The trust score already incorporates OCR confidence, SSIM, overlap
    # Only hard failure reasons (OCR_DISAGREEMENT, EMPTY_RESULT) should
    # override the trust score.
    hard_failures = {FailureReason.OCR_DISAGREEMENT, FailureReason.EMPTY_RESULT,
                     FailureReason.SEGMENTATION_FAILURE}
    has_hard_failure = any(r in hard_failures for r in reasons)

    if trust >= TRUST_THRESHOLD and not has_hard_failure:
        status = TrustStatus.TRUSTED
    else:
        status = TrustStatus.UNTRUSTED

    render_badge = status == TrustStatus.UNTRUSTED
    tooltip = _build_badge_tooltip(reasons) if render_badge else ""

    return NumericValue(
        digits=ocr_result.validated_text,
        trust_score=round(trust, 4),
        status=status,
        failure_reasons=reasons,
        page=page_number,
        bbox=ocr_result.bbox,
        original_text=ocr_result.original_text,
        ocr_confidence=round(ocr_result.trust_score, 4),
        visual_ssim=round(validation.ssim_score, 4) if validation else 0.0,
        visual_overlap=round(validation.pixel_overlap, 4) if validation else 0.0,
        dual_ocr_agreed=ocr_result.dual_agreed,
        font_size=font_size,
        render_badge=render_badge,
        badge_tooltip=tooltip,
    )


def reconstruct_page_numbers(
    ocr_results: List[TokenOCRResult],
    validations: List[ValidationResult],
    page_number: int,
    token_font_sizes: Optional[List[float]] = None,
) -> List[NumericValue]:
    """Reconstruct all numeric values for a page.

    Args:
        ocr_results: Dual-OCR results for each numeric token.
        validations: Visual validation results (parallel list).
        page_number: 1-based page number.
        token_font_sizes: Font sizes for each token (optional).

    Returns:
        List of NumericValue with trust scoring.
    """
    values = []

    for i, ocr_result in enumerate(ocr_results):
        validation = validations[i] if i < len(validations) else None
        font_size = token_font_sizes[i] if token_font_sizes and i < len(token_font_sizes) else 0.0

        nv = reconstruct_numeric_value(
            ocr_result=ocr_result,
            validation=validation,
            page_number=page_number,
            font_size=font_size,
        )
        values.append(nv)

    return values


def page_trust_summary(values: List[NumericValue]) -> dict:
    """Generate trust summary statistics for a page.

    Returns:
        Dict with counts and percentages.
    """
    total = len(values)
    if total == 0:
        return {
            "total": 0,
            "trusted": 0,
            "untrusted": 0,
            "pct_trusted": 100.0,
            "pct_untrusted": 0.0,
            "avg_trust_score": 0.0,
            "partial_failure": False,
        }

    trusted = sum(1 for v in values if v.status == TrustStatus.TRUSTED)
    untrusted = total - trusted
    avg_score = sum(v.trust_score for v in values) / total

    return {
        "total": total,
        "trusted": trusted,
        "untrusted": untrusted,
        "pct_trusted": round(trusted / total * 100, 1),
        "pct_untrusted": round(untrusted / total * 100, 1),
        "avg_trust_score": round(avg_score, 4),
        "partial_failure": untrusted > 0,
    }
